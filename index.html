<!DOCTYPE HTML>
<title>live timezone map</title>
<!-- FIXME: requires builds from separate repositories -->
<script src="tz.js/tz.js.gz"></script>
<script src="tzmap.js/tzmap.js"></script>
<script>
function tzmap_loaded() {
    document.getElementById("loadingtext").firstChild.data = "";
    show_polygons_for(new Date());
}
function tzmap_failed() {
    document.getElementById("loadingtext").firstChild.data = "Loading timezone data failed.";
}
document.addEventListener("DOMContentLoaded", function(event) {
    tzmap.loadData("tzmap.js/", tzmap_loaded, tzmap_failed);
}, false);
</script>
<script src="http://maps.googleapis.com/maps/api/js?v=3.6&amp;sensor=false"></script>
<script>
var gMap, gZoneTime;
function dom_load_handler() {
    gZoneTime = document.getElementById("zonetime");

    var mapOptions = {
        zoom: 2,
        mapTypeId: google.maps.MapTypeId.TERRAIN,
        center: new google.maps.LatLng(15, 0),
    };
    gMap = new google.maps.Map(document.getElementById("map"), mapOptions);
}

/**
 * For a given Date object |d|, return an object mapping UTC offsets to
 * an object with a zones property listing all the time zones with that
 * UTC offset at the given date.
 */
function zone_groups_for(d) {
    var groups = {};
    var zones = tz.allZones();
    for (var zoneIdx in zones) {
        var zone = zones[zoneIdx];
        var info = tz.zoneAt(zone, d);
        if (info.offset in groups) {
            groups[info.offset].zones.push(zone);
        } else {
            groups[info.offset] = { zones: [ zone ] };
        }
    }
    for (var offset in groups) {
        // Keep the lists sorted so we can compare them stably.
        groups[offset].zones.sort();
    }
    return groups;
}

function tzmap_polygons_to_gmaps_Polygon(polygons, options) {
    var topArray = [];
    for (var polygonIdx in polygons) {
        var innerArray = [];
        var polygon = polygons[polygonIdx];
        for (var pointIdx in polygon) {
            var pt = polygon[pointIdx];
            innerArray.push(new google.maps.LatLng(pt[1], pt[0]));
        }
        topArray.push(innerArray);
    }
    options.paths = topArray;
    return new google.maps.Polygon(options);
}

var gHourColors = [
    "hsl(0, 75%, 25%)",
    "hsl(30, 75%, 25%)",
    "hsl(60, 75%, 25%)",
    "hsl(120, 75%, 25%)",
    "hsl(240, 70%, 30%)",
    "hsl(300, 65%, 35%)",
    "hsl(0, 60%, 40%)",
    "hsl(30, 55%, 45%)",
    "hsl(60, 50%, 50%)",
    "hsl(120, 50%, 50%)",
    "hsl(240, 50%, 50%)",
    "hsl(300, 50%, 50%)",
    "hsl(0, 50%, 50%)",
    "hsl(30, 50%, 50%)",
    "hsl(60, 50%, 50%)",
    "hsl(120, 50%, 50%)",
    "hsl(240, 55%, 45%)",
    "hsl(300, 60%, 40%)",
    "hsl(0, 65%, 35%)",
    "hsl(30, 70%, 30%)",
    "hsl(60, 75%, 25%)",
    "hsl(120, 75%, 25%)",
    "hsl(240, 75%, 25%)",
    "hsl(300, 75%, 25%)"
];

var gMonthNames = [
    "January", "February", "March", "April", "May", "June",
    "July", "August", "September", "October", "November", "December"
];

var gDayNames = [
    "Sunday", "Monday", "Tuesday", "Wednesday",
    "Thursday", "Friday", "Saturday"
];

function padmins(min) {
    return ((min < 10) ? "0" : "") + min;
}

function display_text_for(offset, d) {
    var du = new Date(d.valueOf() + offset * 1000);

    // The UTC offset
    var minutePart = Math.abs(offset) / 60;
    var hourPart = Math.floor(minutePart / 60);
    minutePart -= hourPart * 60;

    return gDayNames[du.getUTCDay()] + " (" +
           gMonthNames[du.getUTCMonth()] + " " + du.getUTCDate() +
           ") at " + du.getUTCHours() + ":" +
           padmins(du.getUTCMinutes()) + " (UTC" +
           ((offset < 0) ? "-" : "+") + hourPart + ":" +
           padmins(minutePart) + ")";
}

function color_for_offset(d, offset) {
    var color;
    if (offset % 3600 == 0) {
        color = gHourColors[(d.getUTCHours() + 24 + (offset / 3600)) % 24];
    } else {
        // FIXME: stripe the adjacent hours, if possible
        color = "#999999";
    }
    return color;
}

function show_polygon(d, offset, groupobj) {
    groupobj.color = color_for_offset(d, offset);
    groupobj.polygon = tzmap_polygons_to_gmaps_Polygon(
                      tzmap.polygonsFor(groupobj.zones), {
        fillOpacity: 0.3,
        fillColor: groupobj.color,
        strokeOpacity: 0.5,
        strokeColor: "black",
        strokeWeight: 1,
        zIndex: 20,
        clickable: true, // needed for mouseout/over
        map: gMap
    });
    groupobj.textNode = document.createTextNode(display_text_for(offset, d));
    groupobj.hovered = false;

    function over() {
        groupobj.polygon.setOptions({ strokeColor: "#999900",
                                      strokeOpacity: 1.0,
                                      fillColor: "yellow",
                                      zIndex: 30});
        gZoneTime.appendChild(groupobj.textNode);
        groupobj.hovered = true;
    }
    function out() {
        groupobj.polygon.setOptions({ strokeColor: "black",
                                      strokeOpacity: 0.5,
                                      fillColor: groupobj.color,
                                      zIndex: 20});
        gZoneTime.removeChild(groupobj.textNode);
        groupobj.hovered = false;
    }
    google.maps.event.addListener(groupobj.polygon, 'mouseover', over);
    google.maps.event.addListener(groupobj.polygon, 'mouseout', out);
}

function remove_polygon(groupobj) {
    groupobj.polygon.setMap(null);
    // FIXME: remove listeners?  Note that we want mouseout to fire if
    // in when removed.
}

var gCurrentGroups;

function groups_match(a, b) {
    // Since both sets of groups have the same zones put into them, we
    // only need to enumerate the offsets of one.  If the sets of
    // offsets are different, we will catch a zone missing.
    for (var offset in a) {
        if (!(offset in b)) {
            return false;
        }
        if (JSON.stringify(a[offset].zones) !=
            JSON.stringify(b[offset].zones)) {
            return false;
        }
    }
    return true;
}

function show_polygons_for(d) {
    var groups = zone_groups_for(d);
    if (gCurrentGroups && groups_match(groups, gCurrentGroups)) {
        for (var offset in gCurrentGroups) {
            var groupobj = gCurrentGroups[offset];
            groupobj.textNode.data = display_text_for(offset, d);
            groupobj.color = color_for_offset(d, offset);
            if (!groupobj.hovered) {
                groupobj.polygon.setOptions({ fillColor: groupobj.color });
            }
        }
        return;
    }
    for (var offset in gCurrentGroups) {
        remove_polygon(gCurrentGroups[offset]);
    }
    gCurrentGroups = groups;
    for (var offset in groups) {
        show_polygon(d, offset, groups[offset]);
    }
}

window.addEventListener("DOMContentLoaded", dom_load_handler);
</script>
<style>
html, body { width: 100%; height: 100%; margin: 0; padding: 0; }
body { display: table; border-spacing: 0 }
#ui, #mapcontainer { display: table-row; }
#mapcontainer, #map { height: 100% }
</style>
<div id="ui">Present time.  <span id="loadingtext">Loading timezone data...</span><span id="zonetime"></span></div>
<div id="mapcontainer"><div id="map"></div></div>
