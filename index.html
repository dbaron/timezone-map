<!DOCTYPE HTML>
<title>live timezone map</title>
<meta charset="UTF-8">
<!-- FIXME: requires builds from separate repositories -->
<script src="tz.js/tz.js.gz"></script>
<script src="tzmap.js/tzmap.js"></script>
<script>
var gMapLoaded = false;
function tzmap_loaded() {
    document.getElementById("loadingtext").firstChild.data = "";
    gMapLoaded = true;
    hashchange_listener();
}
function tzmap_failed() {
    document.getElementById("loadingtext").firstChild.data = "Loading timezone data failed.";
}
document.addEventListener("DOMContentLoaded", function(event) {
    tzmap.loadData("tzmap.js/", tzmap_loaded, tzmap_failed);
}, false);
</script>
<script src="http://maps.googleapis.com/maps/api/js?v=3.6&amp;sensor=false"></script>
<script>
var gDefaults = {
    zoom: 2,
    lat: 15,
    lng: 0,
    mapTypeId: google.maps.MapTypeId.ROADMAP,
    time: "now"  // "now" or a number in seconds since the epoch
};
function gethash() {
    var hash = {};
    if (window.location.hash != "") {
        try {
            hash = JSON.parse(unescape(window.location.hash.substring(1)));
        } catch(ex) {}
    }
    for (var prop in gDefaults) {
        if (!(prop in hash)) {
            hash[prop] = gDefaults[prop];
        }
    }
    return hash;
}

function sethash(json) {
    window.location.hash = escape(JSON.stringify(json));
}

var gMap, gZoneTime, gTimeDesc, gNowTimer, gState;
function dom_load_handler() {
    gZoneTime = document.getElementById("zonetime");
    gTimeDesc = document.getElementById("timedesc").firstChild;
    gTimeChooser = document.getElementById("timechooser");

    gState = gethash();
    sethash(gState);

    var mapOptions = {
        zoom: gState.zoom,
        mapTypeId: gState.mapTypeId,
        center: new google.maps.LatLng(gState.lat, gState.lng),
    };
    gMap = new google.maps.Map(document.getElementById("map"), mapOptions);

    google.maps.event.addListener(gMap, 'center_changed',
                                  center_changed_listener);
    google.maps.event.addListener(gMap, 'zoom_changed',
                                  zoom_changed_listener);
    google.maps.event.addListener(gMap, 'maptypeid_changed',
                                  maptypeid_changed_listener);

    hashchange_listener();

    window.addEventListener("hashchange", hashchange_listener, false);

    document.getElementById("dropdown").addEventListener("click",
        function(event) {
            if (event.button != 0 || event.detail != 1)
                return;
            event.stopPropagation();
            toggle_chooser_dropdown();
        }, false);
    gTimeChooser.addEventListener("click",
        function(event) {
            if (event.detail != 1)
                return;
            event.stopPropagation();
        }, false);
    document.body.addEventListener("click",
        function(event) {
            if (event.detail != 1)
                return;
            if (gDropdownOpen) {
                toggle_chooser_dropdown();
            }
        }, false);
}

function center_changed_listener() {
    var ctr = gMap.getCenter();
    gState.lat = ctr.lat();
    gState.lng = ctr.lng();
    sethash(gState);
}

function zoom_changed_listener() {
    gState.zoom = gMap.getZoom();
    sethash(gState);
}

function maptypeid_changed_listener() {
    gState.mapTypeId = gMap.getMapTypeId();
    sethash(gState);
}

function hashchange_listener() {
    gState = gethash();
    gMap.setZoom(gState.zoom);
    gMap.setCenter(new google.maps.LatLng(gState.lat, gState.lng));
    gMap.setMapTypeId(gState.mapTypeId);

    if (gState.time == "now") {
        if (gNowTimer === undefined && gMapLoaded) {
            now_timer();
        }
        gTimeDesc.data = "Present time.";
    } else {
        if (gNowTimer !== undefined) {
            clearTimeout(gNowTimer);
            gNowTimer = undefined;
        }
        if (typeof(gState.time) == "number") {
            if (gMapLoaded) {
                show_polygons_for(new Date(gState.time * 1000));
            }
            // FIXME: better description
            // FIXME: add support for a time zone this was in reference to
            gTimeDesc.data = gState.time + " seconds since the epoch.";
        }
    }
}

function now_timer() {
    var d = new Date();
    gNowTimer = setTimeout(now_timer, (60 - d.getUTCSeconds()) * 1000);
    show_polygons_for(d);
}

/**
 * For a given Date object |d|, return an object mapping UTC offsets to
 * an object with a zones property listing all the time zones with that
 * UTC offset at the given date.
 */
function zone_groups_for(d) {
    var groups = {};
    var zones = tzmap.allZones();
    for (var zoneIdx in zones) {
        var tzmapZone = zones[zoneIdx];
        var tzZone = tz.canonicalName(tzmapZone);
        if (!tzZone) {
            if (tzmapZone != "uninhabited") {
                console.log("Bad zone name " + tzmapZone + " in tzmap database.");
            }
            continue;
        }
        var info = tz.zoneAt(tzZone, d);
        if (info.offset in groups) {
            groups[info.offset].zones.push(tzmapZone);
        } else {
            groups[info.offset] = { zones: [ tzmapZone ] };
        }
    }
    for (var offset in groups) {
        // Keep the lists sorted so we can compare them stably.
        groups[offset].zones.sort();
    }
    return groups;
}

function tzmap_polygons_to_gmaps_Polygon(polygons, options) {
    var topArray = [];
    for (var polygonIdx in polygons) {
        var innerArray = [];
        var polygon = polygons[polygonIdx];
        for (var pointIdx in polygon) {
            var pt = polygon[pointIdx];
            innerArray.push(new google.maps.LatLng(pt[1], pt[0]));
        }
        topArray.push(innerArray);
    }
    options.paths = topArray;
    return new google.maps.Polygon(options);
}

var gHourColors = [
    "hsl(0, 100%, 25%)",
    "hsl(30, 100%, 25%)",
    "hsl(60, 100%, 25%)",
    "hsl(120, 100%, 25%)",
    "hsl(240, 100%, 30%)",
    "hsl(300, 100%, 40%)",
    "hsl(0, 100%, 50%)",
    "hsl(30, 100%, 60%)",
    "hsl(60, 100%, 65%)",
    "hsl(120, 100%, 65%)",
    "hsl(240, 100%, 65%)",
    "hsl(300, 100%, 65%)",
    "hsl(0, 100%, 65%)",
    "hsl(30, 100%, 65%)",
    "hsl(60, 100%, 65%)",
    "hsl(120, 100%, 65%)",
    "hsl(240, 100%, 60%)",
    "hsl(300, 100%, 50%)",
    "hsl(0, 100%, 40%)",
    "hsl(30, 100%, 30%)",
    "hsl(60, 100%, 25%)",
    "hsl(120, 100%, 25%)",
    "hsl(240, 100%, 25%)",
    "hsl(300, 100%, 25%)"
];

var gMonthNames = [
    "January", "February", "March", "April", "May", "June",
    "July", "August", "September", "October", "November", "December"
];

var gDayNames = [
    "Sunday", "Monday", "Tuesday", "Wednesday",
    "Thursday", "Friday", "Saturday"
];

function padmins(min) {
    return ((min < 10) ? "0" : "") + min;
}

function display_text_for(offset, d) {
    var du = new Date(d.valueOf() + offset * 1000);

    // The UTC offset
    var minutePart = Math.abs(offset) / 60;
    var hourPart = Math.floor(minutePart / 60);
    minutePart -= hourPart * 60;

    return gDayNames[du.getUTCDay()] + " (" +
           gMonthNames[du.getUTCMonth()] + " " + du.getUTCDate() +
           ") at " + du.getUTCHours() + ":" +
           padmins(du.getUTCMinutes()) + " (UTC" +
           ((offset < 0) ? "-" : "+") + hourPart + ":" +
           padmins(minutePart) + ")";
}

function color_for_offset(d, offset) {
    var color;
    if (offset % 3600 == 0) {
        color = gHourColors[(d.getUTCHours() + 24 + (offset / 3600)) % 24];
    } else {
        // FIXME: stripe the adjacent hours, if possible
        color = "#999999";
    }
    return color;
}

function show_polygon(d, offset, groupobj) {
    groupobj.color = color_for_offset(d, offset);
    groupobj.polygon = tzmap_polygons_to_gmaps_Polygon(
                      tzmap.polygonsFor(groupobj.zones), {
        fillOpacity: 0.3,
        fillColor: groupobj.color,
        strokeOpacity: 0.5,
        strokeColor: "black",
        strokeWeight: 1,
        zIndex: 20,
        clickable: true, // needed for mouseout/over
        map: gMap
    });
    groupobj.textNode = document.createTextNode(display_text_for(offset, d));
    groupobj.hovered = false;

    function over() {
        groupobj.polygon.setOptions({ strokeColor: "#999900",
                                      strokeOpacity: 1.0,
                                      fillColor: "yellow",
                                      zIndex: 30});
        gZoneTime.appendChild(groupobj.textNode);
        groupobj.hovered = true;
    }
    function out() {
        groupobj.polygon.setOptions({ strokeColor: "black",
                                      strokeOpacity: 0.5,
                                      fillColor: groupobj.color,
                                      zIndex: 20});
        gZoneTime.removeChild(groupobj.textNode);
        groupobj.hovered = false;
    }
    google.maps.event.addListener(groupobj.polygon, 'mouseover', over);
    google.maps.event.addListener(groupobj.polygon, 'mouseout', out);
}

function remove_polygon(groupobj) {
    groupobj.polygon.setMap(null);
    // FIXME: remove listeners?  Note that we want mouseout to fire if
    // in when removed.
}

var gCurrentGroups;

function groups_match(a, b) {
    // Since both sets of groups have the same zones put into them, we
    // only need to enumerate the offsets of one.  If the sets of
    // offsets are different, we will catch a zone missing.
    for (var offset in a) {
        if (!(offset in b)) {
            return false;
        }
        if (JSON.stringify(a[offset].zones) !=
            JSON.stringify(b[offset].zones)) {
            return false;
        }
    }
    return true;
}

function show_polygons_for(d) {
    var groups = zone_groups_for(d);
    if (gCurrentGroups && groups_match(groups, gCurrentGroups)) {
        for (var offset in gCurrentGroups) {
            var groupobj = gCurrentGroups[offset];
            groupobj.textNode.data = display_text_for(offset, d);
            groupobj.color = color_for_offset(d, offset);
            if (!groupobj.hovered) {
                groupobj.polygon.setOptions({ fillColor: groupobj.color });
            }
        }
        return;
    }
    for (var offset in gCurrentGroups) {
        remove_polygon(gCurrentGroups[offset]);
    }
    gCurrentGroups = groups;
    for (var offset in groups) {
        show_polygon(d, offset, groups[offset]);
    }
}

window.addEventListener("DOMContentLoaded", dom_load_handler);

var gTimeChooser;
var gDropdownOpen = false;
function toggle_chooser_dropdown() {
    gTimeChooser.setAttribute("class", gDropdownOpen ? "closed" : "open");
    gDropdownOpen = !gDropdownOpen;
}
</script>
<style>
html, body { width: 100%; height: 100%; margin: 0; padding: 0; }
body { display: table; border-spacing: 0 }
#ui, #mapcontainer { display: table-row; }
#mapcontainer, #map { height: 100% }
#ui { position: relative }

#map { position: relative; z-index: 1 }
#chooser-container { position: relative; z-index: 2 }

#timechooser { position: relative; display: inline-block; padding: 2px; background: blue; color: white }
#chooser-container-outer { position: absolute; height: 0; bottom: 0; left: 0; }
#timechooser.closed > #chooser-container-outer { display: none }
#chooser-container { width: 25em; background: white; color: blue }
#dropdown { border: none; padding: 0; margin: 0; background: transparent; color: inherit; }
#chooser-container ul, #chooser-container li { list-style-type: none; margin: 0; padding: 0 }
#chooser-container li > ul { padding-left: 2em }
#github { position: absolute; top: 0; right: 0 }
</style>
<div id="ui">
  <div id="timechooser" class="closed">
    <span id="timedesc">Present time.</span>
    <button id="dropdown">[v]</button>

    <div id="chooser-container-outer">
      <div id="chooser-container">
        <ul>
          <li><label for="present"><input type="radio" name="time" value="present" id="present">Present time</label></li>
          <li><label for="specific"><input type="radio" name="time" value="specific" id="specific">Specific time</label>:
            <input type="text" size="4" name="year" placeholder="YYYY">-<input type="text" size="2" name="month" placeholder="MM">-<input type="text" size="2" name="date" placeholder="DD">
            <ul>
              <li><label for="utc"><input type="radio" name="zone" value="utc" id="utc">UTC</label></li>
              <li><label for="byplace"><input type="radio" name="zone" value="byplace" id="byplace">At Location (FIXME: add location selector)</label></li>
            </ul>
          </li>
        </ul>
      </div>
    </div>
  </div>
  <span id="loadingtext">Loading timezone data...</span><span id="zonetime"></span>
  <div id="github"><a href="https://github.com/dbaron/timezone-map/">source on GitHub</a></div>
  </div>
<div id="mapcontainer"><div id="map"></div></div>
